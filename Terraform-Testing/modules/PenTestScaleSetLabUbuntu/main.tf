# Resource Group
resource "azurerm_resource_group" "vmss_rg" {
  name     = var.resource_group_name
  location = var.location
  tags     = var.tags
}

# Virtual Network
resource "azurerm_virtual_network" "vmss_vnet" {
  name                = "${var.vmss_name}-vnet"
  address_space       = [var.vnet_address_space]
  location            = azurerm_resource_group.vmss_rg.location
  resource_group_name = azurerm_resource_group.vmss_rg.name
  tags                = var.tags
}

# VMSS Subnet
resource "azurerm_subnet" "vmss_subnet" {
  name                 = "${var.vmss_name}-subnet"
  resource_group_name  = azurerm_resource_group.vmss_rg.name
  virtual_network_name = azurerm_virtual_network.vmss_vnet.name
  address_prefixes     = [var.subnet_address_prefix]
}

# Subnet for Azure Bastion
resource "azurerm_subnet" "bastion_subnet" {
  name                 = "AzureBastionSubnet" # Required name for Bastion subnet
  resource_group_name  = azurerm_resource_group.vmss_rg.name
  virtual_network_name = azurerm_virtual_network.vmss_vnet.name
  address_prefixes     = [var.bastion_subnet_address_prefix]
}

# Network Security Group for VMSS
resource "azurerm_network_security_group" "vmss_nsg" {
  name                = "${var.vmss_name}-nsg"
  location            = azurerm_resource_group.vmss_rg.location
  resource_group_name = azurerm_resource_group.vmss_rg.name
  tags                = var.tags

  # Inbound rules for VMSS - only allow specific traffic
 
  security_rule {
      name                       = "AllowHttpsInbound"
      priority                   = 100
      direction                  = "Inbound"
      access                     = "Allow"
      protocol                   = "Tcp"
      source_port_range          = "*"
      destination_port_range     = "443"
      source_address_prefix      = "Internet"
      destination_address_prefix = "*"
  }
  security_rule {
      name                       = "AllowAzureLoadBalancerInbound"
      priority                   = 101
      direction                  = "Inbound"
      access                     = "Allow"
      protocol                   = "Tcp"
      source_port_range          = "*"
      destination_port_range     = "443"
      source_address_prefix      = "AzureLoadBalancer"
      destination_address_prefix = "*"
  }
   
  security_rule {
      name                       = "AllowAzureGatewayManagerInbound"
      priority                   = 102
      direction                  = "Inbound"
      access                     = "Allow"
      protocol                   = "*"
      source_port_range          = "*"
      destination_port_range     = "443"
      source_address_prefix      = "GatewayManager"
      destination_address_prefix = "*"
  }
   
  security_rule {
      name                       = "AllowBastionInbound"
      priority                   = 103
      direction                  = "Inbound"
      access                     = "Allow"
      protocol                   = "*"
      source_port_range          = "*"
      destination_port_ranges     = ["5701", "8080"]
      source_address_prefix      = "VirtualNetwork"
      destination_address_prefix = "VirtualNetwork"
  }

# Outbound rules for VMSS - allow all outbound traffic
  security_rule {
      name                       = "AllowSshRdpOutbound"
      priority                   = 100
      direction                  = "Outbound"
      access                     = "Allow"
      protocol                   = "*"
      source_port_range          = "*"
      destination_port_ranges     = ["22", "3389"]
      source_address_prefix      = "*"
      destination_address_prefix = "VirtualNetwork"
  }
  security_rule {
      name                       = "AllowAzureCloudOutbound"
      priority                   = 101
      direction                  = "Outbound"
      access                     = "Allow"
      protocol                   = "*"
      source_port_range          = "*"
      destination_port_range     = "443"
      source_address_prefix      = "*"
      destination_address_prefix = "AzureCloud"
  }
  security_rule {
      name                       = "AllowBastionHostCommunicationOutbound"
      priority                   = 102
      direction                  = "Outbound"
      access                     = "Allow"
      protocol                   = "*"
      source_port_range          = "*"
      destination_port_range     = "80"
      source_address_prefix      = "*"
      destination_address_prefix = "Internet"
  }
  security_rule {
      name                       = "AllowHttpOutbound"
      priority                   = 103
      direction                  = "Outbound"
      access                     = "Allow"
      protocol                   = "*"
      source_port_range          = "*"
      destination_port_ranges     = ["5701", "8080"]
      source_address_prefix      = "VirtualNetwork"
      destination_address_prefix = "VirtualNetwork"
  }
}

# NSG association with VMSS subnet
resource "azurerm_subnet_network_security_group_association" "vmss_nsg_association" {
  subnet_id                 = azurerm_subnet.vmss_subnet.id
  network_security_group_id = azurerm_network_security_group.vmss_nsg.id
}


# Public IP for Azure Bastion
resource "azurerm_public_ip" "bastion_ip" {
  name                = "${var.vmss_name}-bastion-ip"
  location            = azurerm_resource_group.vmss_rg.location
  resource_group_name = azurerm_resource_group.vmss_rg.name
  allocation_method   = "Static"
  sku                 = "Standard"
  tags                = var.tags
}

# Azure Bastion Host
resource "azurerm_bastion_host" "vmss_bastion" {
  name                = "${var.vmss_name}-bastion"
  location            = azurerm_resource_group.vmss_rg.location
  resource_group_name = azurerm_resource_group.vmss_rg.name
  tags                = var.tags

  ip_configuration {
    name                 = "configuration"
    subnet_id            = azurerm_subnet.bastion_subnet.id
    public_ip_address_id = azurerm_public_ip.bastion_ip.id
  }
}

# NSG association with Bastion subnet
resource "azurerm_subnet_network_security_group_association" "bastion_nsg_association" {
  subnet_id                 = azurerm_subnet.bastion_subnet.id
  network_security_group_id = azurerm_network_security_group.vmss_nsg.id

  depends_on = [ azurerm_bastion_host.vmss_bastion ]
}

# Application insights for health monitoring
resource "azurerm_application_insights" "vmss_insights" {
  name                = "${var.vmss_name}-insights"
  location            = azurerm_resource_group.vmss_rg.location
  resource_group_name = azurerm_resource_group.vmss_rg.name
  application_type    = "web"
  tags                = var.tags
}

# Load balancer for the VMSS
resource "azurerm_lb" "vmss_lb" {
  name                = "${var.vmss_name}-lb"
  location            = azurerm_resource_group.vmss_rg.location
  resource_group_name = azurerm_resource_group.vmss_rg.name
  sku                 = "Standard"
  tags                = var.tags

  frontend_ip_configuration {
    name                          = "internal"
    subnet_id                     = azurerm_subnet.vmss_subnet.id
    private_ip_address_allocation = "Dynamic"
  }
}

resource "azurerm_lb_backend_address_pool" "vmss_pool" {
  loadbalancer_id = azurerm_lb.vmss_lb.id
  name            = "${var.vmss_name}-bap"
  
  lifecycle {
    create_before_destroy = true
  }
}

resource "azurerm_lb_probe" "vmss_probe" {
  loadbalancer_id = azurerm_lb.vmss_lb.id
  name            = "http-probe"
  port            = 80
  protocol        = "Http"
  request_path    = "/health"
  
  lifecycle {
    create_before_destroy = true
  }
}

# User-assigned managed identity
resource "azurerm_user_assigned_identity" "vmss_identity" {
  name                = "${var.vmss_name}-identity"
  resource_group_name = azurerm_resource_group.vmss_rg.name
  location            = azurerm_resource_group.vmss_rg.location
  tags                = var.tags
}

# Azure AD Group for VM administrators (optional)
resource "azuread_group" "vmss_admins" {
  count            = var.create_admin_group ? 1 : 0
  display_name     = "${var.vmss_name}-admins"
  security_enabled = true
  description      = "Administrators for ${var.vmss_name} Virtual Machine Scale Set"
}

# Azure AD Group membership (optional)
resource "azuread_group_member" "vmss_admin_members" {
  count            = var.create_admin_group && length(var.admin_group_members) > 0 ? length(var.admin_group_members) : 0
  group_object_id  = azuread_group.vmss_admins[0].id
  member_object_id = var.admin_group_members[count.index]
}

# Custom role definition for VMSS management
resource "azurerm_role_definition" "vmss_manager" {
  name        = "${var.vmss_name}-manager"
  scope       = azurerm_resource_group.vmss_rg.id
  description = "Custom role for managing the VMSS"

  permissions {
    actions = [
      "Microsoft.Compute/virtualMachineScaleSets/read",
      "Microsoft.Compute/virtualMachineScaleSets/write",
      "Microsoft.Compute/virtualMachineScaleSets/start/action",
      "Microsoft.Compute/virtualMachineScaleSets/restart/action",
      "Microsoft.Compute/virtualMachineScaleSets/deallocate/action",
      "Microsoft.Compute/virtualMachineScaleSets/redeploy/action",
      "Microsoft.Compute/virtualMachineScaleSets/vmSizes/read",
      "Microsoft.Compute/virtualMachineScaleSets/virtualmachines/read",
      "Microsoft.Compute/virtualMachineScaleSets/virtualmachines/start/action",
      "Microsoft.Compute/virtualMachineScaleSets/virtualmachines/restart/action",
      "Microsoft.Compute/virtualMachineScaleSets/virtualmachines/deallocate/action",
      "Microsoft.Compute/virtualMachineScaleSets/instanceView/read",
      "Microsoft.Compute/virtualMachineScaleSets/virtualmachines/instanceView/read",
      "Microsoft.Compute/virtualMachineScaleSets/extensions/read"
    ]
    not_actions = []
  }

  assignable_scopes = [
    azurerm_resource_group.vmss_rg.id
  ]
}

# Virtual Machine Scale Set
resource "azurerm_linux_virtual_machine_scale_set" "vmss" {
  name                            = var.vmss_name
  resource_group_name             = azurerm_resource_group.vmss_rg.name
  location                        = azurerm_resource_group.vmss_rg.location
  sku                             = var.vmss_sku
  instances                       = var.vmss_instance_count
  admin_username                  = var.admin_username
  admin_password                  = local.administrator_login_password 
  disable_password_authentication = false
  tags                            = var.tags
  # health_probe_id                 = azurerm_lb_probe.vmss_probe.id 
  upgrade_mode                    = "Automatic" // or "Manual"
  
  # Explicitly define dependencies
  depends_on = [
    azurerm_lb.vmss_lb,
    azurerm_lb_backend_address_pool.vmss_pool,
    azurerm_lb_probe.vmss_probe,
    azurerm_subnet.vmss_subnet,
    azurerm_user_assigned_identity.vmss_identity
  ]

  # Boot diagnostics with managed storage account
  boot_diagnostics {
    storage_account_uri = null # Uses managed storage account
  }

  source_image_reference {
    publisher = "Canonical"
    offer     = "0001-com-ubuntu-server-jammy"
    sku       = "22_04-lts-gen2"
    version   = "latest"
  }

  os_disk {
    storage_account_type = "Premium_LRS"
    caching              = "ReadWrite"
  }

  network_interface {
    name                          = "${var.vmss_name}-nic"
    primary                       = true
    enable_accelerated_networking = true

    ip_configuration {
      name                                   = "internal"
      primary                                = true
      subnet_id                              = azurerm_subnet.vmss_subnet.id
      load_balancer_backend_address_pool_ids = [azurerm_lb_backend_address_pool.vmss_pool.id]
    }
  }

  identity {
    type         = "SystemAssigned, UserAssigned"
    identity_ids = [azurerm_user_assigned_identity.vmss_identity.id]
  }

  # extension {
  #   name                       = "AADSSHLoginForLinux"
  #   publisher                  = "Microsoft.Azure.ActiveDirectory"
  #   type                       = "AADSSHLoginForLinux"
  #   type_handler_version       = "1.0"
  #   auto_upgrade_minor_version = true
  # }

  extension {
    name                       = "HealthExtension"
    publisher                  = "Microsoft.ManagedServices"
    type                       = "ApplicationHealthLinux"
    type_handler_version       = "1.0"
    auto_upgrade_minor_version = true

    settings = jsonencode({
      protocol    = "http"
      port        = 80
      requestPath = "/health"
    })
  }

  # extension {
  #   name                       = "DependencyAgentLinux"
  #   publisher                  = "Microsoft.Azure.Monitoring.DependencyAgent"
  #   type                       = "DependencyAgentLinux"
  #   type_handler_version       = "9.10"
  #   auto_upgrade_minor_version = true
  # }

  lifecycle {
    ignore_changes = [
      instances, # Ignore changes to instance count as autoscaling will manage this
    ]
    
    # This ensures proper cleanup order during destroy
    create_before_destroy = true
    
    # This helps with modifications that might otherwise fail
    prevent_destroy = false
  }
}

# LB rule defined AFTER the VMSS with explicit dependency
resource "azurerm_lb_rule" "vmss_rule" {
  loadbalancer_id                = azurerm_lb.vmss_lb.id
  name                           = "http"
  protocol                       = "Tcp"
  frontend_port                  = 80
  backend_port                   = 80
  frontend_ip_configuration_name = "internal"
  backend_address_pool_ids       = [azurerm_lb_backend_address_pool.vmss_pool.id]
  probe_id                       = azurerm_lb_probe.vmss_probe.id
  
  depends_on = [
    azurerm_linux_virtual_machine_scale_set.vmss
  ]
  
  lifecycle {
    create_before_destroy = true
  }
}

# Role Assignment for Virtual Machine Administrator Login
resource "azurerm_role_assignment" "vmss_login" {
  scope                = azurerm_linux_virtual_machine_scale_set.vmss.id
  role_definition_name = "Virtual Machine Administrator Login"
  principal_id         = azurerm_user_assigned_identity.vmss_identity.principal_id
  
  depends_on = [
    azurerm_linux_virtual_machine_scale_set.vmss
  ]
}

# Role Assignment for VM Contributing Monitoring
resource "azurerm_role_assignment" "vmss_monitor" {
  scope                = azurerm_linux_virtual_machine_scale_set.vmss.id
  role_definition_name = "Monitoring Contributor"
  principal_id         = azurerm_user_assigned_identity.vmss_identity.principal_id
  
  depends_on = [
    azurerm_linux_virtual_machine_scale_set.vmss
  ]
}

# Assign the custom role to the user-assigned identity
resource "azurerm_role_assignment" "vmss_manager_role" {
  scope              = azurerm_resource_group.vmss_rg.id
  role_definition_id = azurerm_role_definition.vmss_manager.role_definition_resource_id
  principal_id       = azurerm_user_assigned_identity.vmss_identity.principal_id
  
  depends_on = [
    azurerm_role_definition.vmss_manager,
    azurerm_user_assigned_identity.vmss_identity
  ]
}

# Optional: Assign the managed identity to specific users or groups in Azure AD
resource "azurerm_role_assignment" "user_vmss_access" {
  count                = var.admin_principal_id != "" ? 1 : 0
  scope                = azurerm_user_assigned_identity.vmss_identity.id
  role_definition_name = "Managed Identity Operator"
  principal_id         = var.admin_principal_id
  
  depends_on = [
    azurerm_user_assigned_identity.vmss_identity
  ]
}

# Auto-shutdown schedule for the VMs in the scale set
# resource "azurerm_dev_test_global_vm_shutdown_schedule" "shutdown" {
#   virtual_machine_id    = azurerm_linux_virtual_machine_scale_set.vmss.id
#   location              = azurerm_resource_group.vmss_rg.location
#   enabled               = true
#   daily_recurrence_time = "1900" # 7:00 PM
#   timezone              = "US Mountain Standard Time"
#   notification_settings {
#     enabled = false
#   }
  
#   depends_on = [
#     azurerm_linux_virtual_machine_scale_set.vmss
#   ]
# }

# Auto-scaling profile based on memory usage
resource "azurerm_monitor_autoscale_setting" "vmss_autoscale" {
  name                = "${var.vmss_name}-autoscale"
  resource_group_name = azurerm_resource_group.vmss_rg.name
  location            = azurerm_resource_group.vmss_rg.location
  target_resource_id  = azurerm_linux_virtual_machine_scale_set.vmss.id
  tags                = var.tags
  
  depends_on = [
    azurerm_linux_virtual_machine_scale_set.vmss
  ]

  profile {
    name = "MemoryUsageProfile"

    capacity {
      default = var.vmss_instance_count
      minimum = var.vmss_min_instances
      maximum = var.vmss_max_instances
    }

    # Scale out rule - High memory usage
    rule {
      metric_trigger {
        metric_name        = "Available Memory Bytes"
        metric_resource_id = azurerm_linux_virtual_machine_scale_set.vmss.id
        time_grain         = "PT1M"
        statistic          = "Average"
        time_window        = "PT5M"
        time_aggregation   = "Average"
        operator           = "LessThan"
        threshold          = 1073741824 # 1GB available memory - scale out if memory less than this
        metric_namespace   = "Microsoft.Compute/virtualMachineScaleSets"
      }

      scale_action {
        direction = "Increase"
        type      = "ChangeCount"
        value     = "1"
        cooldown  = "PT5M"
      }
    }

    # Scale in rule - Low memory usage
    rule {
      metric_trigger {
        metric_name        = "Available Memory Bytes"
        metric_resource_id = azurerm_linux_virtual_machine_scale_set.vmss.id
        time_grain         = "PT1M"
        statistic          = "Average"
        time_window        = "PT5M"
        time_aggregation   = "Average"
        operator           = "GreaterThan"
        threshold          = 3221225472 # 3GB available memory - scale in if memory more than this
        metric_namespace   = "Microsoft.Compute/virtualMachineScaleSets"
      }

      scale_action {
        direction = "Decrease"
        type      = "ChangeCount"
        value     = "1"
        cooldown  = "PT5M"
      }
    }
  }
}